# 1.《了不起的Javascript工程师》读书笔记

此书视野开阔，知识点讲解覆盖面广，同时又干货满满。

## 第1章 开发环境 1

### 1.1　代码编写工具 2
#### 1.1.1　IDE 2
#### 1.1.2　编辑器 3
#### 1.1.3　最佳选择 3

### 1.2　Docker容器 5
#### 1.2.1　Docker概述 5
#### 1.2.2　Docker重要概念 6
#### 1.2.3　Docker使用场景 11
#### 1.2.4　Docker扩展 15

### 1.3　代码管理 15
#### 1.3.1　什么是代码仓库 16
#### 1.3.2　版本管理的意义 16
#### 1.3.3　版本管理的常用操作 16
#### 1.3.4　分支管理的意义 17
#### 1.3.5　分支管理的常用操作 17
#### 1.3.6　分支管理流程 18

### 1.4　其他软件 23
#### 1.4.1　文件夹管理软件 23
#### 1.4.2　快速搜索工具 24
#### 1.4.3　终端管理软件 25
#### 1.4.4　Chrome中的插件 25

### 1.5　硬件提升 26
#### 1.5.1　提升程序运行速度 26
#### 1.5.2　减少程序切换时间 27

### 1.6　小结 28

## 第2章 Web页面与多页应用 29

### 2.1　Web页面的运行环境——浏览器 29
#### 2.1.1　渲染引擎 30
#### 2.1.2　JavaScript引擎 38
#### 2.1.3　数据持久层 40
### 2.2　HTML 41
### 2.3　模板 42
#### 2.3.1　模板的意义 42
#### 2.3.2　常用模板分类 42
#### 2.3.3　模板的重要功能 42
### 2.4　CSS盒模型 45
### 2.5　CSS 46
### 2.6　CSS布局 47
#### 2.6.1　普通文档流 47
#### 2.6.2　浮动 57
#### 2.6.3　定位 61
#### 2.6.4　弹性盒模型 62
### 2.7　CSS预处理 68
#### 2.7.1　预处理的意义 68
#### 2.7.2　预处理的重要功能 69
#### 2.7.3　样式文件规划 72
#### 2.7.4　样式类命名 73
### 2.8　JavaScript 77
#### 2.8.1　实现功能逻辑 77
#### 2.8.2　操作页面或浏览器 78
#### 2.8.3　进行网络通信 79
#### 2.8.4　第三方JavaScript库——jQuery 84
#### 2.8.5　JavaScript简史 84
### 2.9　自动化构建工具 85
#### 2.9.1　自动化构建工具的作用 85
#### 2.9.2　常用的自动化构建工具 85
### 2.10　小结 86

## 第3章 高效编写/组织代码的心法 87
### 3.1　拆分方式 89
3.1.1　按文件类型拆分 89
3.1.2　按功能类型拆分 90
3.1.3　按关注点拆分 90
### 3.2　抽象原则 91
3.2.1　第一原则：DRY 91
3.2.2　第二原则：YAGNI 92
3.2.3　第三原则：The Rule of Three 93
### 3.3　不止于代码 94
3.4　小结 94

## 第4章 模块 96
### 4.1　模块的意义 96
### 4.2　ECMAScript 5中的模块 96
4.2.1　立即执行函数表达式（Immediately-Invoked Function Expression） 97
4.2.2　显式模块声明 97
4.2.3　异步模块定义 98
4.2.4　共同模块定义 99
4.2.5　CommonJS 100
4.2.6　通用模块定义 101
### 4.3　ECMAScript 6中的模块 102
### 4.4　模块打包工具 103
4.5　小结 107

## 第5章 单页应用（SPA） 108
### 5.1　框架 109
### 5.2　视图与数据 110
5.2.1　双向数据绑定 111
5.2.2　单向数据流 115
### 5.3　路由 116
5.3.1　hash 116
5.3.2　history 117
### 5.4　组件 119
5.4.1　原生组件 119
5.4.2　第三方组件 121
5.5　小结 123

## 第6章 JavaScript的几个趋势 124
### 6.1　接口与数据类型 125
### 6.2　更好的异步解决方案 127
### 6.3　面向对象与类 132
6.3.1　封装 132
6.3.2　继承 134
6.3.3　多态 135
### 6.4　模块化 138
6.5　小结 141

## 第7章 小程序概述 142
### 7.1　常见的App 142
### 7.2　JavaScript开发者的一双翅膀 143
### 7.3　小程序的发展 144
7.4　小结 144

## 第8章 小程序与Web页面 145
### 8.1　WXML 145
8.1.1　WXML与HTML的相同之处 145
8.1.2　WXML与HTML的不同之处 146
### 8.2　WXSS 149
8.2.1　WXSS与CSS的相同点 149
8.2.2　WXSS与CSS的不同点 149
### 8.3　JavaScript与WXS 155
### 8.4　JSON 155
8.4.1　app.json 155
8.4.2　project.config.json 156
8.4.3　page.json 157
8.4.4　component.json 158
8.5　小结 158

## 第9章 小程序与单页应用 159
### 9.1　路由 159
9.1.1　路由配置 159
9.1.2　路由跳转 160
9.1.3　路由监听 161
### 9.2　组件 162
9.2.1　组件与页面 162
9.2.2　小程序组件与单页应用组件 164
### 9.3　web-view 165
9.3.1　作用 165
9.3.2　交互 165
9.4　小结 165

## 第10章 小程序的框架与插件 166
10.1　RxWX 166
10.2　WePY 168
10.3　mpvue 171
10.4　Taro 171
10.5　小结 171

## 第11章 小程序的开发工具与发布 173
### 11.1　开发者工具组成 173
11.1.1　模拟器 174
11.1.2　调试器 174
11.1.3　编辑器 176
11.1.4　其他功能 176
### 11.2　发布流程 177
11.2.1　小程序的版本 177
11.2.2　用户身份与权限 178
11.3　小结 178

## 第12章 其他混合应用简介 180
12.1　流应用 180
12.2　桌面应用 181
12.3　小结 182

## 第13章 HTTP协议与Web网站 183
13.1　HTTP的历史 183
13.2　HTTP的通信方式 183
13.3　HTTP的状态 184
13.4　小结 184

## 第14章 HTTP协议内容 185
### 14.1　请求行/状态行 186
14.1.1　URL 186
14.1.2　请求方法 188
14.1.3　状态码/状态信息 188
### 14.2　头部 192
14.2.1　通用头部字段 192
14.2.2　请求头部字段 194
14.2.3　响应头部字段 196
14.2.4　主体头部字段 196
14.2.5　其他头部字段 197
### 14.3　主体 198
### 14.4　Cookie 199
14.4.1　Cookie的分类 199
14.4.2　Cookie的使用 199
14.4.3　Cookie的缺陷 200
14.4.4　Cookie与存储 201
### 14.5　Cookie与状态 204
14.5.1　状态存储 205
14.5.2　状态获取 207
14.5.3　基于token的认证方式更好 207
14.6　小结 208

## 第15章 HTTP请求优化 209
### 15.1　减少连接/请求数 209
15.1.1　减少请求 209
15.1.2　减少连接 210
15.2　缓存数据 210
15.3　减少传输数据量 210
15.4　优化网络链路 210
15.4.1　减少域名 211
15.4.2　使用CDN 211
15.5　小结 211

## 第16章 HTTP/2协议 212
### 16.1　多路复用 212
### 16.2　压缩 214
### 16.3　支持TLS 215
### 16.4　应用层协议协商 215
### 16.5　服务器端推送 215
### 16.6　流控制 216
16.7　小结 216

## 第17章 HTTPS协议 217
### 17.1　HTTP的缺点 217
17.1.1　通信使用明文 217
17.1.2　不验证通信方身份 218
17.1.3　无法证明报文的完整性 218
### 17.2　理解HTTPS 219
17.2.1 HTTPS通信流程 219
17.2.2 密码学基础 221
17.2.3 摘要与签名 221
17.2.4 X.509与证书 222
17.3　小结 223

## 第18章 WebSocket协议 224
### 18.1　WebSocket与HTTP 224
### 18.2　WebSocket的使用 224
18.2.1　客户端 225
18.2.2　服务器端 226
18.3　小结 227

## 第19章 API 228
### 19.1　REST 228
19.1.1　REST API设计 228
19.1.2　REST API工具 230
### 19.2　GraphQL 231
19.2.1　GraphQL设计 232
19.2.2　GraphQL工具 234
19.3　小结 235

## 第20章 Node.js概述 237
### 20.1　为什么要学习Node.js 237
### 20.2　什么是Node.js 238
### 20.3　Node.js的历史 239
### 20.4　Node.js的结构 240
### 20.5　Node.js的运行机制 241
#### 20.5.1　单线程 241
#### 20.5.2　事件循环 242
### 20.6　学习Node.js的三个挑战 244
20.6.1　I/O回调 244
20.6.2　代码性能 244
20.6.3　多进程协作 245
20.7　小结 245

## 第21章 用Node.js编写Web服务器端 246
### 21.1　处理请求 246
21.1.1　创建服务器端 246
21.1.2　解析请求 247
### 21.2　响应结果 250
21.2.1　状态信息 250
21.2.2　响应头部 251
21.2.3　响应主体 251
### 21.3　路由解析 253
21.4　I/O操作 260
21.4.1　文件 260
21.4.2　数据库 264
21.4.3　网络请求 267
### 21.5　Web框架 270
21.5.1　Express 271
21.5.2　Koa 271
21.6　小结 271

### 第22章 Node.js内存控制 273
### 22.1　内存限制 273
### 22.2　内存管理 276
22.2.1　内存分配 276
22.2.2　内存回收 276
### 22.3　内存泄漏 277
22.3.1　缓存 277
22.3.2　不断增长的数组 279
22.3.3　重复的事件监听 279
### 22.4　大内存处理 281
22.5　小结 283

## 第23章 Node.js多进程 284
### 23.1　PM2模块 284
23.1.1　安装与使用 285
23.1.2　进程通信 286
23.1.3　进程管理 287
### 23.2　cluster模块 290
23.2.1　基本使用 291
23.2.2　进程通信 294
23.2.3　进程管理 294
### 23.3　child_process模块 298
23.3.1　基本使用 298
23.3.2　进程通信 298
23.3.3　进程管理 302
### 23.4　worker_threads模块 303
23.4.1　基本使用 303
23.4.2　线程通信 304
23.4.3　线程管理 305
23.5　小结 306

## 第24章 Node.js调试与测试 307
### 24.1　开发工具 307
### 24.2　调试工具 307
24.2.1　debug模块 308
24.2.2　Node Inspector 309
### 24.3　单元测试 312
24.3.1　单元测试的意义 312
24.3.2　单元测试代码编写原则 312
24.3.3　测试框架 314
24.3.4　测试风格 316
24.3.5　测试指标 317
24.4　小结 319

