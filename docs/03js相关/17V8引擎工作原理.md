# 11.V8引擎工作原理

## 垃圾回收机制（GC）

[垃圾回收（Garbage Collection，缩写为GC）](https://zh.wikipedia.org/zh-hans/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8))是一种自动的存储器管理机制。

当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分内存空间。

垃圾回收器可以减轻程序员的负担，也减少程序中的错误。垃圾回收最早起源于`LISP语言`。

目前许多语言如Smalltalk、Java、C#和D语言都支持垃圾回收器，我们熟知的 JavaScript 具有自动垃圾回收机制。

在 JavaScript 中，原始类型的数据被分配到栈空间中，引用类型的数据会被分配到堆空间中。

### 栈空间中的垃圾回收
当函数 `showName` 调用完成后，通过下移 ESP（Extended Stack Pointer）指针，来销毁 showName 函数，之后调用其他函数时，将覆盖掉旧内存，存放另一个函数的执行上下文，实现垃圾回收。

图片来自《浏览器工作原理与实践》

### 堆空间中的垃圾回收
堆中数据垃圾回收策略的基础是：代际假说（The Generational Hypothesis）。即：

大部分对象在内存中存在时间极短，很多对象很快就不可访问。
不死的对象将活得更久。

这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。
V8 引擎将堆空间分为新生代（存放生存时间短的对象）和老生代（存放生存时间长的对象）两个区域，并使用不同的垃圾回收器。

副垃圾回收器，主要负责新生代的垃圾回收。
主垃圾回收器，主要负责老生代的垃圾回收。

不管是哪种垃圾回收器，都使用相同垃圾回收流程：标记活动对象和非活动对象，回收非活动对象的内存，最后内存整理。
**
### 副垃圾回收器
使用 Scavenge 算法处理，将新生代空间对半分为两个区域，一个对象区域，一个空闲区域。

图片来自《浏览器工作原理与实践》
执行流程：

新对象存在在对象区域，当对象区域将要写满时，执行一次垃圾回收；
垃圾回收过程中，首先对对象区域中的垃圾做标记，然后副垃圾回收器将存活的对象复制并有序排列到空闲区域，相当于完成内存整理。
复制完成后，将对象区域和空闲区域翻转，完成垃圾回收操作，这也让新生代中两块区域无限重复使用。

当然，这也存在一些问题：若复制操作的数据较大则影响清理效率。
JavaScript 引擎的解决方式是：将新生代区域设置得比较小，并采用对象晋升策略（经过两次回收仍存活的对象，会被移动到老生区），避免因为新生代区域较小引起存活对象装满整个区域的问题。
### 主垃圾回收器
分为：标记 - 清除（Mark-Sweep）算法，和标记 - 整理（Mark-Compact）算法。
a)标记 - 清除（Mark-Sweep）算法
过程：

标记过程：从一组根元素开始遍历整个元素，能到达的元素为活动对象，反之为垃圾数据；
清除过程：清理被标记的数据，并产生大量碎片内存。（缺点：导致大对象无法分配到足够的连续内存）


图片来自《浏览器工作原理与实践》
b)标记 - 整理（Mark-Compact）算法
过程：

标记过程：从一组根元素开始遍历整个元素，能到达的元素为活动对象，反之为垃圾数据；
整理过程：将所有存活的对象，向一段移动，然后清除端边界以外的内容。


图片来自《浏览器工作原理与实践》
3. 拓展阅读
1.《图解Java 垃圾回收机制》
2.《MDN 内存管理》

## 事件循环（Event Loop）