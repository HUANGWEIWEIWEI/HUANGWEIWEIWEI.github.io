# 前端开发的模块化进化史



## 定义

JavaScript本身是弱化命名空间概念的，只有全局作用域和函数的私有作用域（ES6中新增块作用域），而模块化开发，强化了命名空间的概念

## 作用

代码分离、解耦、复用
团队开发
避免命名重复
相互引用，按需加载


## 单例设计模式

Singleton Pattern 最早的模块化管理

```js
let xxxModule=(function(){
    function fn(){
        //...
    }
    return{
        init(){
            //...
        }
    }
})();

xxxModule.init();
```

## AMD规范

Asynchronous Module Definition 异步模块定义规范

--代表：require 
--官网：  https://requirejs.org

AMD规范是非同步加载模块，允许指定回调函数。

AMD标准中，定义了下面两个API：

require([module], callback)
define(id, [depends], callback)
　　即通过define来定义一个模块，然后使用require来加载一个模块。 并且，require还支持CommonJS的模块导出方式。

>AMD与RequireJS的关系
>AMD是RequireJS在推广过程中对模块定义的规范化产出，它是一个概念，RequireJS是对这个概念的实现，就好比JavaScript语言是对ECMAScript规范的实现。AMD是一个组织，RequireJS是在这个组织下自定义的一套脚本语言

>RequireJS：是一个AMD框架，可以异步加载JS文件，按照模块加载方法，通过define()函数定义，第一个参数是一个数组，里面定义一些需要依赖的包，第二个参数是一个回调函数，通过变量来引用模块里面的方法，最后通过return来输出。
是一个依赖前置、异步定义的AMD框架（在参数里面引入js文件），在定义的同时如果需要用到别的模块，在最前面定义好即在参数数组里面进行引入，在回调里面加载


### 使用

开发目录里的main.js全局配置

![](https://gitee.com/hello_hww/img/raw/master/img1/20200622203042.png)

main.js
```js
require.config({
    baseUrl:'js/lib',
});
require(['moduleB','moduleA'],function(moduleB,moduleA){
    console.log(moduleB.average(10,20,30,40,50));
});
```

moduleA.js
```js
define(function(){
    return{
        sum(...arg){
            return arg.reduce((total,item)=>{
                return total+item;
            })
        }
    }
})
```

moduleB.js
```js
define(['moduleA'],fuction(moduleA){
    return{
        average(...args){
            args.sort((a,b)=>a-b);
            args.pop();
            args.shift();
            return moduleA.sum(...args)/arg.length;
        }
    };
});
```

### 特点

依赖前置。在定义一个新的模块之前，要把依赖的模块全部设定好


## CMD规范

Common Module Define 通用模块定义规范

--代表：sea.js
--官网：  https://seajs.org
>SeaJS是淘宝团队提供的一个模块开发的js框架.


CMD是同步模块定义。

//所有模块都通过define来定义
define(function(require, exports, module) {  
  // 通过require引入依赖
  var $ = require('jquery');
  var Spinning = require('./spinning');
  exports.doSomething = ...
  module.exports = ...
})

二者的区别是前者是对于依赖的模块提前执行，而后者是延迟执行。 前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块的时候再require。

### 使用

```js
define(function(require,exports,module){
    //通过require引入依赖
    let $=require('jquery');
    let spinning=require(./spinning);

    //通过module.exports提供接口
    module.exports={
        init(){}
    };
});
```

### 特点

CMD比AMD更灵活

CMD参考CommonJS规范，可以运行在客户端

## CommonJS规范---module.exports

前端浏览器不支持，一般用于服务器开发，例如NodeJS

CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。

在CommenJS里面，require一个模块，相当于执行了该模块并得到模块输出的module.exports对象的一份拷贝，重复引入不会重复执行

### 使用

导入 require
导出 module.exports

A.js
```js
function sum(x,y){
    console.log(x+y);
}
module.exports={
    sun
}
```
B.js
```js
let x=10,y=20;
let A=require('./A');
//第一次引用，module.exports导出的结果拷贝一份给变量
A.sum(x,y);

A=require('./A');
//第二次引用，内部默认看看之前有无导入过，如有则不会再把A代码重新执行，而是直接获取上一次拷贝的信息

```

## ES6 Module规范

ESM：JS官方标准模块定义方式

ES6Module是JS新增的模块导入导出规范（不同于AMD和CMD[CommenJS],ES6Module是静态编译的）

>动态编译：代码执行到具体位置的时候才会进行模块的导入导出
>静态编译：先按照依赖的关系把模块导入导出编译，再执行代码

在ES6中，我们可以使用 import 关键字引入模块，通过 exprot 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的，但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。

### 特点

模块的导入都要放在代码的最前面--浏览器不能直接识别，需要先进行编译才可以（webpack可以完成这个编译）

如果没有编译就执行，会报语法错误
```
Uncaught SyntaxError:Cannot use import statement outside a module
```

### 导出

export

export default
``    导出一个
``    对应导入一个  import c from './C.js';

### 导入

导入多个 import {sum,n} from './A.js';

导入全部 import * as A from './A'
``此时使用A.sum()、A.n

### 例

A.js
```js
export function sum(x,y){
    return x+y;
}
```

B.js
```js
import{
    sum,n
}from './A.js';
// import * as A from './A';
// A.sum()
// A.n
import c from './C.js';

console.log(sum(10,20));
console.log(c(10,20));
```

## 对比分析小结

commonjs是用在服务器端的，同步的，如nodejs
amd, cmd是用在浏览器端的，异步的，如requirejs和seajs

以后开发尽量：
浏览器端用ES6的export/import
服务器端用CommenJS的module.exports/require

## webpack时代

### webpack的优点：

1.require.js的所有功能它都有

2.编绎过程更快，因为require.js会去处理不需要的文件

3.还有一个额外的好处就是你不需要再做一个封装的函数，require.js中你得这样
define([‘jquery’], function(jquery){})

4.现在你需要一个很大的封装去定义每个模块，然后你需要在在require.js的配制文件中将每个模块的路径都配出来，用过requirejs都会遇到的好繁琐

#### 对比requirejs seajs webpack特有的属性：

1.对 CommonJS 、 AMD 、ES6的语法做了兼容

2.对js、css、图片等资源文件都支持打包（css都可以合成多个css文件包，sass和less虽然也是模块化的加载合并，可是css和js分离的关联不大，这里的css可以和js有更大的关联，更细致区分加载的js）

3.串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持

4.有独立的配置文件webpack.config.js

5.可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间

6.支持 SourceUrls 和 SourceMaps，易于调试

7.具有强大的Plugin接口，大多是内部插件，使用起来比较灵活

8.webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快

9.双服务器模式



# 参考文章

AMD、CMD、CommonJs、ES6的对比
https://blog.csdn.net/tangxiujiang/article/details/81104174

浅谈前端架构的工程化、模块化、组件化、规范化
https://www.imooc.com/article/48008

