(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{198:function(t,_,a){"use strict";a.r(_);var v=a(6),r=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_01js概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_01js概述"}},[t._v("#")]),t._v(" 01JS概述")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#_1定义"}},[t._v("1定义")])]),a("li",[a("a",{attrs:{href:"#_2发明者"}},[t._v("2发明者")])]),a("li",[a("a",{attrs:{href:"#_3组成"}},[t._v("3组成")])]),a("li",[a("a",{attrs:{href:"#_4特征"}},[t._v("4特征")])]),a("li",[a("a",{attrs:{href:"#_5作用"}},[t._v("5作用")])]),a("li",[a("a",{attrs:{href:"#_6版本迭代"}},[t._v("6版本迭代")])]),a("li",[a("a",{attrs:{href:"#_7拓展"}},[t._v("7拓展")])]),a("li",[a("a",{attrs:{href:"#_36个很重要的js概念"}},[t._v("36个很重要的JS概念")]),a("ul",[a("li",[a("a",{attrs:{href:"#_1-调用堆栈执行"}},[t._v("1. 调用堆栈执行")])]),a("li",[a("a",{attrs:{href:"#_2-原始数据类型"}},[t._v("2. 原始数据类型")])]),a("li",[a("a",{attrs:{href:"#_3-值类型和引用类型"}},[t._v("3. 值类型和引用类型")])]),a("li",[a("a",{attrs:{href:"#_4-强制类型转换"}},[t._v("4. 强制类型转换")])]),a("li",[a("a",{attrs:{href:"#_5-比较运算符号-和-typeof-运算符"}},[t._v("5. 比较运算符号 和 typeof 运算符")])]),a("li",[a("a",{attrs:{href:"#_6-javascript-作用域"}},[t._v("6. JavaScript 作用域")])]),a("li",[a("a",{attrs:{href:"#_7-语句和声明"}},[t._v("7. 语句和声明")])]),a("li",[a("a",{attrs:{href:"#_8-立即调用的函数表达式和模块"}},[t._v("8. 立即调用的函数表达式和模块")])]),a("li",[a("a",{attrs:{href:"#_9-消息队列和事件循环"}},[t._v("9. 消息队列和事件循环")])]),a("li",[a("a",{attrs:{href:"#_10-时间间隔"}},[t._v("10.时间间隔")])]),a("li",[a("a",{attrs:{href:"#_11-js-引擎"}},[t._v("11.JS 引擎")])]),a("li",[a("a",{attrs:{href:"#_12-按位运算"}},[t._v("12.按位运算")])]),a("li",[a("a",{attrs:{href:"#_13-dom-和布局树"}},[t._v("13. DOM 和布局树")])]),a("li",[a("a",{attrs:{href:"#_14-类和工厂"}},[t._v("14.类和工厂")])]),a("li",[a("a",{attrs:{href:"#_15-this-关键字和-apply-call及bind方法"}},[t._v("15.this 关键字和 apply,call及bind方法")])]),a("li",[a("a",{attrs:{href:"#_16-构造函数和-instanceof-运算符"}},[t._v("16.构造函数和 “instanceOf” 运算符")])]),a("li",[a("a",{attrs:{href:"#_17-原型"}},[t._v("17.原型")])]),a("li",[a("a",{attrs:{href:"#_18-使用-new，object-create-和-object-assign-创建对象"}},[t._v("18. 使用 new，Object.create 和 Object.assign 创建对象")])]),a("li",[a("a",{attrs:{href:"#_19-map-filter-reduce-方法"}},[t._v("19.map,filter,reduce 方法")])]),a("li",[a("a",{attrs:{href:"#_20-纯函数，副作用和状态变更"}},[t._v("20.纯函数，副作用和状态变更")])]),a("li",[a("a",{attrs:{href:"#_21-闭包"}},[t._v("21. 闭包")])]),a("li",[a("a",{attrs:{href:"#_22-高阶函数"}},[t._v("22. 高阶函数")])]),a("li",[a("a",{attrs:{href:"#_23-递归"}},[t._v("23.递归")])]),a("li",[a("a",{attrs:{href:"#_24-集合与生成器"}},[t._v("24. 集合与生成器")])]),a("li",[a("a",{attrs:{href:"#_25-promise"}},[t._v("25. Promise")])]),a("li",[a("a",{attrs:{href:"#_26-异步编程"}},[t._v("26.异步编程")])]),a("li",[a("a",{attrs:{href:"#_27-es6-箭头函数"}},[t._v("27. ES6 箭头函数")])]),a("li",[a("a",{attrs:{href:"#_28-数据结构"}},[t._v("28. 数据结构")])]),a("li",[a("a",{attrs:{href:"#_29-时间复杂度"}},[t._v("29.时间复杂度")])]),a("li",[a("a",{attrs:{href:"#_30-算法"}},[t._v("30. 算法")])]),a("li",[a("a",{attrs:{href:"#_31-继承，多态和代码重用"}},[t._v("31. 继承，多态和代码重用")])]),a("li",[a("a",{attrs:{href:"#_32-设计模式"}},[t._v("32. 设计模式")])]),a("li",[a("a",{attrs:{href:"#_33-函数式编程"}},[t._v("33. 函数式编程")])]),a("li",[a("a",{attrs:{href:"#_34-简洁代码的原则"}},[t._v("34. 简洁代码的原则")])]),a("li",[a("a",{attrs:{href:"#_35-解构赋值"}},[t._v("35. 解构赋值")])]),a("li",[a("a",{attrs:{href:"#_36-es2020新特性"}},[t._v("36. ES2020新特性")])])])])])]),a("p"),t._v(" "),a("p",[a("a",{attrs:{href:"02JS%E5%9F%BA%E7%A1%80"}},[t._v("02JS基础")])]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/03js相关/03JS语法.html"}},[t._v("03JS语法.md")])],1),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/03js相关/04JS数据类型.html"}},[t._v("04JS数据类型.md")])],1),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/03js相关/05对象.html"}},[t._v("05对象.md")])],1),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/03js相关/06函数.html"}},[t._v("06函数.md")])],1),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/03js相关/07Symbol.html"}},[t._v("07Symbol.md")])],1),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/03js相关/08DOM.html"}},[t._v("08DOM.md")])],1),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/03js相关/09BOM.html"}},[t._v("09BOM.md")])],1),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/03js相关/10JS异步编程.html"}},[t._v("10JS异步编程.md")])],1),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/03js相关/11JS正则.html"}},[t._v("11JS正则.md")])],1),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/03js相关/12JS设计模式.html"}},[t._v("12JS设计模式.md")])],1),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/03js相关/13JS进阶.html"}},[t._v("13JS进阶.md")])],1),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/03js相关/14函数式编程.html"}},[t._v("14函数式编程.md")])],1),t._v(" "),a("p",[a("a",{attrs:{href:"15Cookie,Session,Token,JWT"}},[t._v("15Cookie,Session,Token,JWT")])]),t._v(" "),a("p",[a("a",{attrs:{href:"16ES6"}},[t._v("16ES6")])]),t._v(" "),a("p",[a("a",{attrs:{href:"17V8%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"}},[t._v("17V8引擎工作原理")])]),t._v(" "),a("p",[a("a",{attrs:{href:"18TypeScript"}},[t._v("18TypeScript")])]),t._v(" "),a("p",[a("a",{attrs:{href:"JS%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"}},[t._v("JS相关面试题")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/hello_hww/img/raw/master/img1/20200821142205.png",alt:"为什么学习js"}})]),t._v(" "),a("p",[t._v("tensorflow.js--机器学习")]),t._v(" "),a("h2",{attrs:{id:"_1定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1定义"}},[t._v("#")]),t._v(" 1定义")]),t._v(" "),a("p",[t._v("JavaScript ( JS ) 是一种具有函数优先的轻量级，解释型或即时编译型的高级编程语言。")]),t._v(" "),a("blockquote",[a("p",[t._v("虽然它是作为开发Web页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。")])]),t._v(" "),a("h2",{attrs:{id:"_2发明者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2发明者"}},[t._v("#")]),t._v(" 2发明者")]),t._v(" "),a("p",[t._v("JavaScript在1995年由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。")]),t._v(" "),a("blockquote",[a("p",[t._v("因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。")])]),t._v(" "),a("h2",{attrs:{id:"_3组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3组成"}},[t._v("#")]),t._v(" 3组成")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("ECMAScript")]),t._v(" 定义了JS的语法规范，JavaScript的标准是ECMAScript。ECMAScript描述了JavaScript的语法和基本对象。")]),t._v(" "),a("li",[a("code",[t._v("DOM")]),t._v(" 文档对象模型 提供对应的属性和方法（文档api），可以让JS操作页面中的DOM元素。")]),t._v(" "),a("li",[a("code",[t._v("BOM")]),t._v(" 浏览器对象模型 提供操作浏览器的属性和方法（浏览器对象api）。")])]),t._v(" "),a("h2",{attrs:{id:"_4特征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4特征"}},[t._v("#")]),t._v(" 4特征")]),t._v(" "),a("p",[t._v("脚本语言、面向对象、弱类型、动态性（基于事件驱动）、跨平台（依赖与浏览器支持）")]),t._v(" "),a("h2",{attrs:{id:"_5作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5作用"}},[t._v("#")]),t._v(" 5作用")]),t._v(" "),a("p",[t._v("后台数据到客户端的渲染，把数据库的数据通过JS操作显示在页面上\n通过浏览器的事件机制，实现用户与网页的交互，达到动态网站效果\n动态修改页面元素，动态操作css与html，这些都说明js通过BOM与DOM可以轻松实现对静态页面的操作，使其拥有动态特性\n在有了ajax之后，客户端可以在不刷新页面的情况下对服务器发起请求，不仅可以在客户端验证数据之后再向服务端发送数据，有些时候还可以直接在客户端计算之后再向服务器返回数据，减少服务器的压力")]),t._v(" "),a("h2",{attrs:{id:"_6版本迭代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6版本迭代"}},[t._v("#")]),t._v(" 6版本迭代")]),t._v(" "),a("table",[a("tbody",[a("tr",[a("th",{staticStyle:{width:"15%"}},[t._v("版本")]),t._v(" "),a("th",{staticStyle:{width:"30%"}},[t._v("官方名称")]),t._v(" "),a("th",[t._v("描述")])]),t._v(" "),a("tr",[a("td",[t._v("1")]),t._v(" "),a("td",[t._v("ECMAScript 1 (1997)")]),t._v(" "),a("td",[t._v("第一版。")])]),t._v(" "),a("tr",[a("td",[t._v("2")]),t._v(" "),a("td",[t._v("ECMAScript 2 (1998)")]),t._v(" "),a("td",[t._v("只改变编辑方式。")])]),t._v(" "),a("tr",[a("td",[t._v("3")]),t._v(" "),a("td",[t._v("ECMAScript 3 (1999)")]),t._v(" "),a("td",[a("ul",[a("li",[t._v("添加了正则表达式。")]),t._v(" "),a("li",[t._v("添加了 try/catch。")])])])]),t._v(" "),a("tr",[a("td",[t._v("4")]),t._v(" "),a("td",[t._v("ECMAScript 4")]),t._v(" "),a("td",[t._v("从未发布过。")])]),t._v(" "),a("tr",[a("td",[t._v("5")]),t._v(" "),a("td",[a("p",[t._v("ECMAScript 5 (2009)")])]),t._v(" "),a("td",[a("ul",[a("li",[t._v("添加了“严格模式”。")]),t._v(" "),a("li",[t._v("添加了 JSON 支持。")]),t._v(" "),a("li",[t._v("添加了 String.trim()。")]),t._v(" "),a("li",[t._v("添加了 Array.isArray()。")]),t._v(" "),a("li",[t._v("添加了数组迭代方法。")])])])]),t._v(" "),a("tr",[a("td",[t._v("5.1")]),t._v(" "),a("td",[t._v("ECMAScript 5.1 (2011)")]),t._v(" "),a("td",[t._v("编辑改变。")])]),t._v(" "),a("tr",[a("td",[t._v("6")]),t._v(" "),a("td",[a("p",[t._v("ECMAScript 2015，被称为ES6")])]),t._v(" "),a("td",[a("ul",[a("li",[t._v("添加了 let 和 const")]),t._v(" "),a("li",[t._v("添加了默认参数值")]),t._v(" "),a("li",[t._v("添加了 Array.find()")]),t._v(" "),a("li",[t._v("添加了 Array.findIndex()")])])])]),t._v(" "),a("tr",[a("td",[t._v("7")]),t._v(" "),a("td",[t._v("ECMAScript 2016")]),t._v(" "),a("td",[a("ul",[a("li",[t._v("添加了指数运算符（**）。")]),t._v(" "),a("li",[t._v("添加了 Array.prototype.includes。")])])])]),t._v(" "),a("tr",[a("td",[t._v("8")]),t._v(" "),a("td",[t._v("ECMAScript 2017")]),t._v(" "),a("td",[a("ul",[a("li",[t._v("添加了字符串填充。")]),t._v(" "),a("li",[t._v("添加了新的 Object 属性。")]),t._v(" "),a("li",[t._v("添加了异步功能。")]),t._v(" "),a("li",[t._v("添加了共享内存。")])])])]),t._v(" "),a("tr",[a("td",[t._v("9")]),t._v(" "),a("td",[t._v("ECMAScript 2018")]),t._v(" "),a("td",[a("ul",[a("li",[t._v("添加了 rest / spread 属性。")]),t._v(" "),a("li",[t._v("添加了异步迭代。")]),t._v(" "),a("li",[t._v("添加了 Promise.finally()。")]),t._v(" "),a("li",[t._v("增加 RegExp。")])])])])])]),t._v(" "),a("h2",{attrs:{id:"_7拓展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7拓展"}},[t._v("#")]),t._v(" 7拓展")]),t._v(" "),a("ol",[a("li",[t._v("v8引擎。只需要有js引擎就可以执行js代码，浏览器有，nodejs有v8引擎就也可以执行js代码。")]),t._v(" "),a("li",[t._v("TS是JS的超集，算是对JS的扩展，它对JS的弱类型加以调整，使其拥有强类型语言的特性。")])]),t._v(" "),a("h2",{attrs:{id:"_36个很重要的js概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_36个很重要的js概念"}},[t._v("#")]),t._v(" 36个很重要的JS概念")]),t._v(" "),a("h3",{attrs:{id:"_1-调用堆栈执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-调用堆栈执行"}},[t._v("#")]),t._v(" 1. 调用堆栈执行")]),t._v(" "),a("p",[t._v("我们都知道堆栈溢出，但是你知道堆栈溢出是由什么原因导致的吗? 堆栈溢出是与"),a("code",[t._v("调用堆栈一些操作错误")]),t._v("相关联的。")]),t._v(" "),a("p",[t._v("理解了调用堆栈，你就会清楚解像是JS 这们的编程语言是如何执行的。")]),t._v(" "),a("h3",{attrs:{id:"_2-原始数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-原始数据类型"}},[t._v("#")]),t._v(" 2. 原始数据类型")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" “bar”"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nfoo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3")]),t._v("\nfoo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" “bar”"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("这里，我们将值bar分配给常量foo时，它属于原始类型string。 这个每个人都知道。 但是各位少侠想没想过一个问题，string是基本数据类型，怎么能调用方法了？")]),t._v(" "),a("p",[t._v("奇怪吗? 不。")]),t._v(" "),a("p",[t._v("这个特性称为"),a("code",[t._v("自动装箱")]),t._v("。每当读取一个基本类型的时候，JS 后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。")]),t._v(" "),a("p",[t._v("还是拿上面的例子开始：")]),t._v(" "),a("p",[t._v("const foo = “bar”;\nfoo.length; // 3\nfoo === “bar”; // true\n变量 foo 是一个基本类型值，它不是对象，它不应该有方法。但是 JS 内部为我们完成了一系列处理（即装箱），使得它能够调用方法,实现的机制如下：")]),t._v(" "),a("p",[t._v("创建String类型的一个实例\n在实例上调用指定的方法\n销毁这个实例\nconst foo = new String(“bar”);\nfoo.length\nfoo === ‘bar’\nfoo = null\n通过对原始数据类型有深入的了解，我们就应该知道这些“怪异”情况是如何发生的，以及它们背后的逻辑原因。")]),t._v(" "),a("h3",{attrs:{id:"_3-值类型和引用类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-值类型和引用类型"}},[t._v("#")]),t._v(" 3. 值类型和引用类型")]),t._v(" "),a("p",[t._v("最近，我对“引用传递” 在 JS 是怎么工作的感到困惑。 尽管我知道 C 和 Java 等语言中有“按引用传递”和“按值传递”的概念，但是我不确定它在 JS 中如何工作。")]),t._v(" "),a("p",[t._v("你是否知道分配给 JS 中非原始值的变量对该值的引用？ 引用指向存储值的内存位置。。")]),t._v(" "),a("p",[t._v("var arr1 = [1,2,3];\nvar arr2 = arr1;\narr2.push(10);\nconsole.log(arr2);\n//[1, 2, 3, 10]\nconsole.log(arr1);\n//[1, 2, 3, 10]\n上面的示例中可以看到，对arr2所做的任何修改也将体现在arr1上。 这是因为它们仅保存值对应的内存地址的引用，而非值本身。")]),t._v(" "),a("p",[t._v("通过了解值类型和引用类型的概念，你就会更好地了解如何为变量分配值和内存引用。")]),t._v(" "),a("h3",{attrs:{id:"_4-强制类型转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-强制类型转换"}},[t._v("#")]),t._v(" 4. 强制类型转换")]),t._v(" "),a("p",[t._v("这个概念主要解释了隐式和显式类型强制之间的区别。 这是前端开发中对 JS 迷惑少数几个领域之一。 对于隐式强制转换的概念尤其如此，因为它对不同的数据类型以不同的方式表现。")]),t._v(" "),a("p",[t._v("这是 JS 面试中最常被考的。")]),t._v(" "),a("p",[t._v("Number(‘789’) // 显式\n+’789’ // 隐式\n789 != ‘456’ // 隐式\n9 > ‘5’ // 隐式\n10/null // 隐式\ntrue | 0 // 隐式\n掌握了类型显隐转换，恭喜你对 JS 了解就进一步了。")]),t._v(" "),a("h3",{attrs:{id:"_5-比较运算符号-和-typeof-运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-比较运算符号-和-typeof-运算符"}},[t._v("#")]),t._v(" 5. 比较运算符号 和 typeof 运算符")]),t._v(" "),a("p",[t._v("双等与三等，它们在大多数情况下在表面上看起来相同并且给出相同的结果，但是，它们有时候可能会给带来意想不到的错误。")]),t._v(" "),a("p",[t._v("为了了解这两亲兄弟的区别，我们可以借助 typeof 来查看被比较的值的类型。")]),t._v(" "),a("p",[t._v("typeof 3 // “number”\ntypeof “abc” // “string”\ntypeof {} // “object”\ntypeof true // “boolean”\ntypeof undefined // “undefined”\ntypeof function(){} // “function”\ntypeof [] // “object”\ntypeof null // “object”")]),t._v(" "),a("h3",{attrs:{id:"_6-javascript-作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-javascript-作用域"}},[t._v("#")]),t._v(" 6. JavaScript 作用域")]),t._v(" "),a("p",[t._v("作用域是 JS 中一个很重要的尴尬，JS 也一直在不断完善自己的作用域。 根据Wissam的说法，作用域的简单定义是，编译器在需要时查找变量和函数。")]),t._v(" "),a("p",[t._v("了解作用域有助于我们有效地使用JavaScript。 我们还需要了解全局作用域以及块和函数作用域，也称为词法作用域。 JS 作用域一开始接触会感到很困惑，但是一旦你了解了事情的幕后原理，使用它就会非常令人兴奋。")]),t._v(" "),a("h3",{attrs:{id:"_7-语句和声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-语句和声明"}},[t._v("#")]),t._v(" 7. 语句和声明")]),t._v(" "),a("p",[t._v("JavaScript 程序是一系列可执行语句的集合。所谓语句，就是一个可执行的单元，通过该语句的执行，从而实现某种功能。通常一条语句占一行，并以分号结束。默认情况下，JavaScript 解释器按照语句的编写流程依次执行。如果要改变这种默认执行顺序，需要使用判断、循环等流程控制语句。")]),t._v(" "),a("p",[t._v("我们应该要知道 语句和声明 的区别，这对我们全面了解 JS 是很有帮助的。")]),t._v(" "),a("h3",{attrs:{id:"_8-立即调用的函数表达式和模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-立即调用的函数表达式和模块"}},[t._v("#")]),t._v(" 8. 立即调用的函数表达式和模块")]),t._v(" "),a("p",[t._v("IIFE: Immediately Invoked Function Expression，意为立即调用的函数表达式，也就是说，声明函数的同时立即调用这个函数。它主要用于避免污染全局作用域。 后来，引入了ES6模块，为避免全局作用域的污染提供了一种标准方法，尽管有人认为它不是IIFE的直接替代。")]),t._v(" "),a("p",[t._v("通过理解IIFE和模块，你可以构建较少由于全局空间处理不当而导致的错误的应用程序。当然，使用模块，我们还可以做很多事情。")]),t._v(" "),a("h3",{attrs:{id:"_9-消息队列和事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-消息队列和事件循环"}},[t._v("#")]),t._v(" 9. 消息队列和事件循环")]),t._v(" "),a("p",[t._v("正如MDN文档所说，JavaScript 有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其它语言中的模型截然不同，比如 C 和 Java。")]),t._v(" "),a("p",[t._v("在并发模型中，消息队列用于处理最早的消息。 只要有事件发生，便会加入消息队列中。通过理解这些概念，你可以更好地理解JS在底层是如何工作的，以及知道你的代码是如果运行的。")]),t._v(" "),a("h3",{attrs:{id:"_10-时间间隔"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-时间间隔"}},[t._v("#")]),t._v(" 10.时间间隔")]),t._v(" "),a("p",[t._v("想在 JS 有计划的调用的函数，可以使用下面两个函数：")]),t._v(" "),a("p",[t._v("setTimeout 允许我们在特定时间间隔后运行一次函数。\nsetInterval允许我们重复运行一个函数，从一个特定的时间间隔开始，然后以该间隔连续重复。\n这些与前面的消息队列和事件处理程序的概念有些关联。因此，通过理解时间间隔方法，我们可以理解它们是如何工作的，并在我们的用例中有效地使用它们。")]),t._v(" "),a("h3",{attrs:{id:"_11-js-引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-js-引擎"}},[t._v("#")]),t._v(" 11.JS 引擎")]),t._v(" "),a("p",[t._v("JavaScript引擎是执行 JS 代码的计算机程序或解释器。JS 引擎可以用多种语言编写。例如，驱动Chrome浏览器的V8引擎是用 c++ 编写的，而驱动Firefox浏览器的SpiderMonkey引擎是用 C 和 c++编 写的。")]),t._v(" "),a("p",[t._v("要想编写高效的代码，你必须了解所使用的 JS 引擎。使用webview的移动开发人员要特别注意这一点。")]),t._v(" "),a("h3",{attrs:{id:"_12-按位运算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-按位运算"}},[t._v("#")]),t._v(" 12.按位运算")]),t._v(" "),a("p",[t._v("按位运算操作将值视为位（0和1），而不是十进制，十六进制或八进制数字。 按位运算符对此类二进制表示形式执行其操作，但是它们返回标准JavaScript数值。")]),t._v(" "),a("p",[t._v("通常，很少会在代码中使用这些操作，但是它们确实有一些用例。 比如，可以使用它们来查找偶数和奇数值，颜色转换，颜色提取等等。")]),t._v(" "),a("p",[t._v("通过全面了解这些按位操作，您可以很好地使用 WebGL 之类的技术，因为它包含许多像素操作。")]),t._v(" "),a("h3",{attrs:{id:"_13-dom-和布局树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-dom-和布局树"}},[t._v("#")]),t._v(" 13. DOM 和布局树")]),t._v(" "),a("p",[t._v("我们大多数人都听说过文档对象模型（DOM），但只有少数人对此有深入的了解。 你知道在浏览器中看到的不是DOM吗？ 而是渲染树，它实际上是DOM和CSSOM的组合。")]),t._v(" "),a("p",[t._v("通过理解DOM的工作方式、结构以及页面的渲染方式，我们就能够在 JS 的帮助下动态地操作web页面。这对于确保我们的应用程序具有高标准的性能尤为必要。")]),t._v(" "),a("h3",{attrs:{id:"_14-类和工厂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-类和工厂"}},[t._v("#")]),t._v(" 14.类和工厂")]),t._v(" "),a("p",[t._v("JavaScript 不是一种面向对象的语言。 但是，为了模仿OOP属性，使用了构造函数。 根据Tania的说法，“ JavaScript中的类实际上并没有提供其他功能，只是在原型和继承上提供语法糖，因为它们提供了更简洁，更优雅的语法。 由于其他编程语言都使用类，因此 JS 中的类语法使开发人员在各种语言之间移动变得更加简单。”")]),t._v(" "),a("p",[t._v("工厂函数是不是返回对象的类或构造函数的函数。 根据JS专家Eric Elliot的说法，“在JavaScript中，任何函数都可以返回一个新对象。 如果它不是构造函数或类，则称为工厂函数。”")]),t._v(" "),a("p",[t._v("当开始开发规模更大的应用程序时，理解这两个概念是很有必要的。")]),t._v(" "),a("h3",{attrs:{id:"_15-this-关键字和-apply-call及bind方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-this-关键字和-apply-call及bind方法"}},[t._v("#")]),t._v(" 15.this 关键字和 apply,call及bind方法")]),t._v(" "),a("p",[t._v("就我个人而言，我认为对于一个JS开发人员来说，理解this 关键字是至关重要的。如果你不能正确地理解它，将来你开发的项目也会经常遇到this相关的问题。")]),t._v(" "),a("p",[t._v("如果你对this关键字很清楚，则可以看看apply，call和bind方法，这些都可以解决 this 指向引发的问题。")]),t._v(" "),a("h3",{attrs:{id:"_16-构造函数和-instanceof-运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-构造函数和-instanceof-运算符"}},[t._v("#")]),t._v(" 16.构造函数和 “instanceOf” 运算符")]),t._v(" "),a("p",[t._v("构造函数就像常规函数一样。 但是它们有很多差异，函数名称以大写字母开头，并且只能由new运算符执行。 具有OOP开发经验的程序员会熟悉new关键字。")]),t._v(" "),a("p",[t._v("为了正确识别对象的类型，我们使用instanceOf运算符。 简单来说，它检查一个对象是否是另一个对象的实例。")]),t._v(" "),a("p",[t._v("这才助于你理解对象如何相互继承，继承是通过原型实现的。")]),t._v(" "),a("h3",{attrs:{id:"_17-原型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-原型"}},[t._v("#")]),t._v(" 17.原型")]),t._v(" "),a("p",[t._v("这是 JS 中最令人困惑的概念之一，即使对于有十年经验的人来说也是如此。")]),t._v(" "),a("p",[t._v("JavaScript中的原型是在对象之间共享通用功能的机制。 JavaScript中几乎所有对象都是Object的实例。 对象会从Object.prototype继承所有属性和方法。")]),t._v(" "),a("p",[t._v("简单来说，原型是 JS 对象从中继承方法和属性的对象。")]),t._v(" "),a("p",[t._v("理解了原型，你就可以构建高效，快速的应用程序。")]),t._v(" "),a("h3",{attrs:{id:"_18-使用-new，object-create-和-object-assign-创建对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-使用-new，object-create-和-object-assign-创建对象"}},[t._v("#")]),t._v(" 18. 使用 new，Object.create 和 Object.assign 创建对象")]),t._v(" "),a("p",[t._v("创建对象有很多方法。 但是，大都会选择Object.create方法而不是new关键字。这是有原因的，因为 使用Object.create方法时，可以将现有对象用作新创建的对象的原型。 这样就可以重用现有对象的属性和功能，有点像OOP中的继承概念。")]),t._v(" "),a("p",[t._v("使用Object.assign方法时，可以将可枚举的自身属性从一个或多个源对象复制到目标对象。 在这种情况下，目标对象的原型不包含源对象的属性。 这是这两种方法之间的主要区别。")]),t._v(" "),a("p",[t._v("通过了解对象创建的这三种方式，可以根据实际情况适当地使用它们，以创建效率更高的程序。")]),t._v(" "),a("h3",{attrs:{id:"_19-map-filter-reduce-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-map-filter-reduce-方法"}},[t._v("#")]),t._v(" 19.map,filter,reduce 方法")]),t._v(" "),a("p",[t._v("当涉及到数组操作时，这三种方法非常有用。 它们可以在Array原型中找到。")]),t._v(" "),a("p",[t._v("如果你有一个数组，并且想对每个元素做一些事情，那么您可以使用map方法。")]),t._v(" "),a("p",[t._v("如果你有一个数组，并且想通过某些条件来过滤一些值时，则可以使用filter方法。")]),t._v(" "),a("p",[t._v("reduce() 方法对数组中的每个元素执行一个由你提供的reducer函数(升序执行)，将其结果汇总为单个返回值。")]),t._v(" "),a("p",[t._v("典型的例子就是对数组的所有元素进行求和：")]),t._v(" "),a("p",[t._v("let numbers = [1,2,3,4,5,6]\nconst reduced = numbers.reduce( (accumulator, currentValue) => accumulator + currentValue )\nconsole.log(reduced)\n// 21\n请注意，上述三种方法不会更改原始数组的值。")]),t._v(" "),a("h3",{attrs:{id:"_20-纯函数，副作用和状态变更"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-纯函数，副作用和状态变更"}},[t._v("#")]),t._v(" 20.纯函数，副作用和状态变更")]),t._v(" "),a("p",[t._v("这三个概念对于 JS 开发人员而言非常重要，状态变更对于使用 React 的开发人员尤其重要。")]),t._v(" "),a("p",[t._v("纯函数指的是一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用。")]),t._v(" "),a("p",[t._v("函数副作用是指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。副作用的函数不仅仅只是返回了一个值，而且还做了其他的事情，比如：")]),t._v(" "),a("p",[t._v("修改了一个变量\n直接修改数据结构\n设置一个对象的成员\n抛出一个异常或以一个错误终止\n打印到终端或读取用户输入\n读取或写入一个文件\n在屏幕上画图\n状态变更是指你更改变量值的地方。 如果你对变量进行更改，则可能会影响到其他函数，具体取决于变量被更改之前的值。 在React环境中，建议我不要改变状态。")]),t._v(" "),a("h3",{attrs:{id:"_21-闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-闭包"}},[t._v("#")]),t._v(" 21. 闭包")]),t._v(" "),a("p",[t._v("闭包很难理解。 但是一旦理解，你会觉得 JS 其实也挺好的。 在线上有足够的资源。 你花足够的时间学习闭包，掌握理解它并不难。")]),t._v(" "),a("p",[t._v("使用闭包可以访问内部作用域中外部作用域的作用域。 每次创建函数时都会在函数创建时创建JavaScript闭包。")]),t._v(" "),a("h3",{attrs:{id:"_22-高阶函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-高阶函数"}},[t._v("#")]),t._v(" 22. 高阶函数")]),t._v(" "),a("p",[t._v("高阶函数是将其他函数作为参数或返回结果的函数。 你可以创建仅负责一项任务的较小函数，然后在这些较小函数的帮助下构造复杂函数。 这也会提交代码的可重用性。")]),t._v(" "),a("h3",{attrs:{id:"_23-递归"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-递归"}},[t._v("#")]),t._v(" 23.递归")]),t._v(" "),a("p",[t._v("递归是所有编程语言中的一个常见概念。简单地说，递归就是把大问题分解成小问题，然后解决小问题一种思路。")]),t._v(" "),a("p",[t._v("尽管递归可能是一个让你头疼的令人困惑的概念，但是通过大量的练习，从一些小问题开始，你可以更好地理解它。")]),t._v(" "),a("h3",{attrs:{id:"_24-集合与生成器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24-集合与生成器"}},[t._v("#")]),t._v(" 24. 集合与生成器")]),t._v(" "),a("p",[t._v("ES6 中新引入了集合和生成器。 新引入的集合有Map，Set，WeakSet和WeakMap。 这些集合为我们提供一些很方便的操作。 了解它们的方式至关重要，尤其是对于现代JavaScript。")]),t._v(" "),a("p",[t._v("生成器有时很难理解，特别是对于初学者。 生成器允许我们编写代码函数，从而能够暂停和重新启动函数，而不会阻止其他代码的执行，这在JavaScript中是很不常见的。")]),t._v(" "),a("h3",{attrs:{id:"_25-promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_25-promise"}},[t._v("#")]),t._v(" 25. Promise")]),t._v(" "),a("p",[t._v("Jecelyn对 Promises 的解释如下：“想象一下你是个孩子。 你妈妈向你保证，她下周会买一部新手机给你。”")]),t._v(" "),a("p",[t._v("你要到下周才能知道你是否能屋那部手机。你的妈妈要么真的给你买了一个全新的手机，要么因为不开心就不给你买。")]),t._v(" "),a("p",[t._v("这算是一个承诺。 一个 Promise 有三个状态，分别是：")]),t._v(" "),a("p",[t._v("Pending:你不知道你是否会能得到那个电话\nFulfilled：妈妈高兴了，给你买了一部新手机\nRejected：老妈不开心了，就是不给买，爱咋滴就咋滳")]),t._v(" "),a("h3",{attrs:{id:"_26-异步编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_26-异步编程"}},[t._v("#")]),t._v(" 26.异步编程")]),t._v(" "),a("p",[t._v("要了解什么是异步编程，首先要先积善成德什么是同步编程。 同步编程是线程阻塞的，由于 JS 是单线程的，因此代码将逐行执行。")]),t._v(" "),a("p",[t._v("但是使用异步代码，你可以执行一些比较耗时的任务。 当你必须执行花费很长时间才能完成的多个任务时，此功能特别有用。 但是在某些情况下，即使是需要执行很长时间的代码，也可能需要用同步的方式，这时就可以使用async/await。")]),t._v(" "),a("h3",{attrs:{id:"_27-es6-箭头函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_27-es6-箭头函数"}},[t._v("#")]),t._v(" 27. ES6 箭头函数")]),t._v(" "),a("p",[t._v("箭头函数是 ES6 的新增功能，是常规函数的语法替代。 区别在于箭头函数不绑定到this，arguments，super或new.target关键字。 这使得箭头函数在某些情况下是一个不错的选择，而在另一些情况下则是一个非常糟糕的选择。")]),t._v(" "),a("p",[t._v("因此，不要一上来就使用箭头函数。 需要根据你实际情况还使用它们。")]),t._v(" "),a("h3",{attrs:{id:"_28-数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_28-数据结构"}},[t._v("#")]),t._v(" 28. 数据结构")]),t._v(" "),a("p",[t._v("无论使用哪种编程语言，数据结构都是开发人员应具备的基本知识之一。")]),t._v(" "),a("p",[t._v("糟糕的程序员担心代码，好的程序员担心数据结构和它们之间的关系。\n数据结构方面，你应该了解链表，队列，堆栈，树，图和哈希表。")]),t._v(" "),a("h3",{attrs:{id:"_29-时间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_29-时间复杂度"}},[t._v("#")]),t._v(" 29.时间复杂度")]),t._v(" "),a("p",[t._v("不管编程语言如何，时间复杂度分析也是计算机编程的另一个基础。 为了构建更好的应用程序，你应该编写更好的解决方案。 为此，你需要了解时间复杂度的概念。 有时也称为BigO。")]),t._v(" "),a("h3",{attrs:{id:"_30-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_30-算法"}},[t._v("#")]),t._v(" 30. 算法")]),t._v(" "),a("p",[t._v("这也是在计算机基础课程中首先要教的内容之一。 简而言之，算法是逐步实现目标的过程。 程序员应该能够从算法的角度看任何问题。")]),t._v(" "),a("p",[t._v("尽管有成千上万个用例的大量算法，但是下面两个很常见：")]),t._v(" "),a("p",[t._v("查找")]),t._v(" "),a("p",[t._v("排序")]),t._v(" "),a("p",[t._v("这两个用例对程序员来说是非常常见的，至少应该了解实现它们的已知算法。没有固定的规则规定你应该使用这些算法之一，但是这些算法在性能方面是众所周知的，并且有很好的文档证明。")]),t._v(" "),a("p",[t._v("你甚至可以创建自己的算法，并将其介绍给世界。如果它比目前已知的算法更好，你可能会成为下一个编程明星")]),t._v(" "),a("h3",{attrs:{id:"_31-继承，多态和代码重用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_31-继承，多态和代码重用"}},[t._v("#")]),t._v(" 31. 继承，多态和代码重用")]),t._v(" "),a("p",[t._v("JS 中的继承可用于原型来实现。 这是因为 JS 是非OOP语言。 但是 JS 通过提供原型继承来提供OOP的某些功能。")]),t._v(" "),a("p",[t._v("多态是对象、变量或函数可以采用多种形式的概念。在 JS 中，要看到多态的效果有点困难，因为在静态类型的系统中，多态的经典类型更明显。")]),t._v(" "),a("p",[t._v("以上两个概念都可以帮助我们在 JS 中实现更好代码重用。")]),t._v(" "),a("h3",{attrs:{id:"_32-设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_32-设计模式"}},[t._v("#")]),t._v(" 32. 设计模式")]),t._v(" "),a("p",[t._v("设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。")]),t._v(" "),a("h3",{attrs:{id:"_33-函数式编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_33-函数式编程"}},[t._v("#")]),t._v(" 33. 函数式编程")]),t._v(" "),a("p",[t._v("函数式编程是一种编程范式，是一种构建计算机程序结构和元素的风格，它把计算看作是对数学函数的评估，避免了状态的变化和数据的可变。")]),t._v(" "),a("p",[t._v("你需要掌握函数式编程的几个概念：")]),t._v(" "),a("p",[t._v("纯函数\n不可变\n引用透明性\n高阶函数")]),t._v(" "),a("h3",{attrs:{id:"_34-简洁代码的原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_34-简洁代码的原则"}},[t._v("#")]),t._v(" 34. 简洁代码的原则")]),t._v(" "),a("p",[t._v("无论使用哪种编程语言，这都是每个开发人员都应该掌握的一项基本技能。 每种编程语言都有一套单独的良好实践。 尽管这些“良好”做法是主观的，并且在工作场所之间存在差异，但有些惯例被认为是“良好”。")]),t._v(" "),a("p",[t._v("通过遵循这些代码原则，可以确保每个人都可以阅读和维护你的代码。 这也会帮助你和你的团队在应用程序开发过程中顺利合作。")]),t._v(" "),a("h3",{attrs:{id:"_35-解构赋值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_35-解构赋值"}},[t._v("#")]),t._v(" 35. 解构赋值")]),t._v(" "),a("p",[t._v("在ES6中引入了解构赋值操作符，它非常有用。对于相同的用例，它们比以前的实现更简单、更有效。")]),t._v(" "),a("h3",{attrs:{id:"_36-es2020新特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_36-es2020新特性"}},[t._v("#")]),t._v(" 36. ES2020新特性")]),t._v(" "),a("p",[t._v("编程的优点之一是，如果你不去不断学习，你永远不会成为该领域专家。 编程语言会随着时间不断发展，因为每个主要版本中都引入了其他新的功能。")]),t._v(" "),a("p",[t._v("这也说明了你对某个概念的专业知识很可能在将来的10年后会过期，因为会有更好的替代版本与版本更新一起发布。 对于任何编程语言，这都是非常常见的情况。")]),t._v(" "),a("p",[t._v("ES2020发布了几个新特性，包括可选链接、空值合并、动态导入等等。你必须学习这些新概念，以跟上快速变化的It世界。")]),t._v(" "),a("p",[t._v("掌握一门语言需要多年的经验和时间，但是知道要掌握什么会让事情变得更容易，希望这 36 个概念能对你有所帮助。"),a("a",{attrs:{href:"https://wzx18216446125.github.io/",target:"_blank",rel:"https://dignified.cn"}},[t._v("参考：狐尼克的个人博客"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("comment-comment")],1)}),[],!1,null,null,null);_.default=r.exports}}]);