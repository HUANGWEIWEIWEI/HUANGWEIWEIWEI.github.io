(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{214:function(a,t,v){"use strict";v.r(t);var _=v(6),e=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"_11-v8引擎工作原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-v8引擎工作原理"}},[a._v("#")]),a._v(" 11.V8引擎工作原理")]),a._v(" "),v("h2",{attrs:{id:"垃圾回收机制（gc）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制（gc）"}},[a._v("#")]),a._v(" 垃圾回收机制（GC）")]),a._v(" "),v("p",[v("a",{attrs:{href:"https://zh.wikipedia.org/zh-hans/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)",target:"_blank",rel:"https://dignified.cn"}},[a._v("垃圾回收（Garbage Collection，缩写为GC）"),v("OutboundLink")],1),a._v("是一种自动的存储器管理机制。")]),a._v(" "),v("p",[a._v("当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分内存空间。")]),a._v(" "),v("p",[a._v("垃圾回收器可以减轻程序员的负担，也减少程序中的错误。垃圾回收最早起源于"),v("code",[a._v("LISP语言")]),a._v("。")]),a._v(" "),v("p",[a._v("目前许多语言如Smalltalk、Java、C#和D语言都支持垃圾回收器，我们熟知的 JavaScript 具有自动垃圾回收机制。")]),a._v(" "),v("p",[a._v("在 JavaScript 中，原始类型的数据被分配到栈空间中，引用类型的数据会被分配到堆空间中。")]),a._v(" "),v("h3",{attrs:{id:"栈空间中的垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈空间中的垃圾回收"}},[a._v("#")]),a._v(" 栈空间中的垃圾回收")]),a._v(" "),v("p",[a._v("当函数 "),v("code",[a._v("showName")]),a._v(" 调用完成后，通过下移 ESP（Extended Stack Pointer）指针，来销毁 showName 函数，之后调用其他函数时，将覆盖掉旧内存，存放另一个函数的执行上下文，实现垃圾回收。")]),a._v(" "),v("p",[a._v("图片来自《浏览器工作原理与实践》")]),a._v(" "),v("h3",{attrs:{id:"堆空间中的垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆空间中的垃圾回收"}},[a._v("#")]),a._v(" 堆空间中的垃圾回收")]),a._v(" "),v("p",[a._v("堆中数据垃圾回收策略的基础是：代际假说（The Generational Hypothesis）。即：")]),a._v(" "),v("p",[a._v("大部分对象在内存中存在时间极短，很多对象很快就不可访问。\n不死的对象将活得更久。")]),a._v(" "),v("p",[a._v("这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。\nV8 引擎将堆空间分为新生代（存放生存时间短的对象）和老生代（存放生存时间长的对象）两个区域，并使用不同的垃圾回收器。")]),a._v(" "),v("p",[a._v("副垃圾回收器，主要负责新生代的垃圾回收。\n主垃圾回收器，主要负责老生代的垃圾回收。")]),a._v(" "),v("p",[a._v("不管是哪种垃圾回收器，都使用相同垃圾回收流程：标记活动对象和非活动对象，回收非活动对象的内存，最后内存整理。\n**")]),a._v(" "),v("h3",{attrs:{id:"副垃圾回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[a._v("#")]),a._v(" 副垃圾回收器")]),a._v(" "),v("p",[a._v("使用 Scavenge 算法处理，将新生代空间对半分为两个区域，一个对象区域，一个空闲区域。")]),a._v(" "),v("p",[a._v("图片来自《浏览器工作原理与实践》\n执行流程：")]),a._v(" "),v("p",[a._v("新对象存在在对象区域，当对象区域将要写满时，执行一次垃圾回收；\n垃圾回收过程中，首先对对象区域中的垃圾做标记，然后副垃圾回收器将存活的对象复制并有序排列到空闲区域，相当于完成内存整理。\n复制完成后，将对象区域和空闲区域翻转，完成垃圾回收操作，这也让新生代中两块区域无限重复使用。")]),a._v(" "),v("p",[a._v("当然，这也存在一些问题：若复制操作的数据较大则影响清理效率。\nJavaScript 引擎的解决方式是：将新生代区域设置得比较小，并采用对象晋升策略（经过两次回收仍存活的对象，会被移动到老生区），避免因为新生代区域较小引起存活对象装满整个区域的问题。")]),a._v(" "),v("h3",{attrs:{id:"主垃圾回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器"}},[a._v("#")]),a._v(" 主垃圾回收器")]),a._v(" "),v("p",[a._v("分为：标记 - 清除（Mark-Sweep）算法，和标记 - 整理（Mark-Compact）算法。\na)标记 - 清除（Mark-Sweep）算法\n过程：")]),a._v(" "),v("p",[a._v("标记过程：从一组根元素开始遍历整个元素，能到达的元素为活动对象，反之为垃圾数据；\n清除过程：清理被标记的数据，并产生大量碎片内存。（缺点：导致大对象无法分配到足够的连续内存）")]),a._v(" "),v("p",[a._v("图片来自《浏览器工作原理与实践》\nb)标记 - 整理（Mark-Compact）算法\n过程：")]),a._v(" "),v("p",[a._v("标记过程：从一组根元素开始遍历整个元素，能到达的元素为活动对象，反之为垃圾数据；\n整理过程：将所有存活的对象，向一段移动，然后清除端边界以外的内容。")]),a._v(" "),v("p",[a._v("图片来自《浏览器工作原理与实践》\n3. 拓展阅读\n1.《图解Java 垃圾回收机制》\n2.《MDN 内存管理》")]),a._v(" "),v("h2",{attrs:{id:"事件循环（event-loop）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件循环（event-loop）"}},[a._v("#")]),a._v(" 事件循环（Event Loop）")]),a._v(" "),v("comment-comment")],1)}),[],!1,null,null,null);t.default=e.exports}}]);